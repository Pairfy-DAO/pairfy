var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Cip30Wallet_instances, _Cip30Wallet_logger, _Cip30Wallet_api, _Cip30Wallet_authenticator, _Cip30Wallet_validateExtensions;
import { APIErrorCode, ApiError } from '../errors/index.js';
export const CipMethodsMapping = {
    30: [
        'getNetworkId',
        'getUtxos',
        'getCollateral',
        'getBalance',
        'getExtensions',
        'getUsedAddresses',
        'getUnusedAddresses',
        'getChangeAddress',
        'getRewardAddresses',
        'signTx',
        'signData',
        'submitTx'
    ],
    95: ['getRegisteredPubStakeKeys', 'getUnregisteredPubStakeKeys', 'getPubDRepKey']
};
export const WalletApiMethodNames = Object.values(CipMethodsMapping).flat();
const wrapAndEnableApi = (walletApi, enabledExtensions) => {
    const baseApi = {
        experimental: {
            getCollateral: (params) => walletApi.getCollateral(params)
        },
        getBalance: () => walletApi.getBalance(),
        getChangeAddress: () => walletApi.getChangeAddress(),
        getCollateral: (params) => walletApi.getCollateral(params),
        getExtensions: () => Promise.resolve(enabledExtensions || []),
        getNetworkId: () => walletApi.getNetworkId(),
        getRewardAddresses: () => walletApi.getRewardAddresses(),
        getUnusedAddresses: () => walletApi.getUnusedAddresses(),
        getUsedAddresses: (paginate) => walletApi.getUsedAddresses(paginate),
        getUtxos: (amount, paginate) => walletApi.getUtxos(amount, paginate),
        signData: (addr, payload) => walletApi.signData(addr, payload),
        signTx: (tx, partialSign) => walletApi.signTx(tx, partialSign),
        submitTx: (tx) => walletApi.submitTx(tx)
    };
    const additionalCipApis = {
        cip95: {
            getPubDRepKey: () => walletApi.getPubDRepKey(),
            getRegisteredPubStakeKeys: () => walletApi.getRegisteredPubStakeKeys(),
            getUnregisteredPubStakeKeys: () => walletApi.getUnregisteredPubStakeKeys()
        }
    };
    if (enabledExtensions) {
        for (const extension of enabledExtensions) {
            const cipName = `cip${extension.cip}`;
            if (additionalCipApis[cipName]) {
                baseApi[cipName] = additionalCipApis[cipName];
            }
        }
    }
    return baseApi;
};
export class Cip30Wallet {
    constructor(properties, { api, authenticator, logger }) {
        _Cip30Wallet_instances.add(this);
        this.apiVersion = '0.1.0';
        this.supportedExtensions = [{ cip: 95 }];
        _Cip30Wallet_logger.set(this, void 0);
        _Cip30Wallet_api.set(this, void 0);
        _Cip30Wallet_authenticator.set(this, void 0);
        this.icon = properties.icon;
        this.name = properties.walletName;
        __classPrivateFieldSet(this, _Cip30Wallet_api, api, "f");
        __classPrivateFieldSet(this, _Cip30Wallet_logger, logger, "f");
        __classPrivateFieldSet(this, _Cip30Wallet_authenticator, authenticator, "f");
        this.enable = this.enable.bind(this);
        this.isEnabled = this.isEnabled.bind(this);
    }
    async isEnabled() {
        return __classPrivateFieldGet(this, _Cip30Wallet_authenticator, "f").haveAccess();
    }
    async enable(options) {
        __classPrivateFieldGet(this, _Cip30Wallet_instances, "m", _Cip30Wallet_validateExtensions).call(this, options?.extensions);
        if (await __classPrivateFieldGet(this, _Cip30Wallet_authenticator, "f").requestAccess()) {
            __classPrivateFieldGet(this, _Cip30Wallet_logger, "f").debug(`${location.origin} has been granted access to wallet api`);
            const extensions = options?.extensions?.filter(({ cip: requestedCip }) => this.supportedExtensions.some(({ cip: supportedCip }) => supportedCip === requestedCip));
            return wrapAndEnableApi(__classPrivateFieldGet(this, _Cip30Wallet_api, "f"), extensions);
        }
        __classPrivateFieldGet(this, _Cip30Wallet_logger, "f").debug(`${location.origin} not authorized to access wallet api`);
        throw new ApiError(APIErrorCode.Refused, 'wallet not authorized.');
    }
}
_Cip30Wallet_logger = new WeakMap(), _Cip30Wallet_api = new WeakMap(), _Cip30Wallet_authenticator = new WeakMap(), _Cip30Wallet_instances = new WeakSet(), _Cip30Wallet_validateExtensions = function _Cip30Wallet_validateExtensions(extensions = []) {
    if (!Array.isArray(extensions) ||
        extensions.some((extension) => !extension || typeof extension !== 'object' || !extension.cip || Number.isNaN(Number(extension.cip)))) {
        __classPrivateFieldGet(this, _Cip30Wallet_logger, "f").debug(`Invalid extensions: ${extensions}`);
        throw new ApiError(APIErrorCode.InvalidRequest, `invalid extensions ${extensions}`);
    }
};
//# sourceMappingURL=Cip30Wallet.js.map