"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Address: () => Address,
  AddressType: () => AddressType,
  AssetId: () => AssetId,
  AssetName: () => AssetName,
  AuxiliaryData: () => AuxiliaryData,
  Bip32PrivateKey: () => Bip32PrivateKey2,
  Bip32PrivateKeyHex: () => Bip32PrivateKeyHex,
  Bip32PublicKey: () => Bip32PublicKey2,
  CborReader: () => CborReader,
  CborReaderState: () => CborReaderState,
  CborSet: () => CborSet,
  CborWriter: () => CborWriter,
  Certificate: () => Certificate,
  CertificateType: () => CertificateType,
  ConstrPlutusData: () => ConstrPlutusData,
  CostModel: () => CostModel,
  Costmdls: () => Costmdls,
  Credential: () => Credential,
  CredentialType: () => CredentialType,
  Datum: () => Datum,
  DatumHash: () => DatumHash,
  DatumKind: () => DatumKind,
  Ed25519KeyHashHex: () => Ed25519KeyHashHex2,
  Ed25519PrivateExtendedKeyHex: () => Ed25519PrivateExtendedKeyHex,
  Ed25519PrivateNormalKeyHex: () => Ed25519PrivateNormalKeyHex,
  Ed25519PublicKey: () => Ed25519PublicKey2,
  Ed25519PublicKeyHex: () => Ed25519PublicKeyHex2,
  Ed25519Signature: () => Ed25519Signature2,
  Ed25519SignatureHex: () => Ed25519SignatureHex2,
  ExUnits: () => ExUnits,
  Hash: () => Hash,
  Hash28ByteBase16: () => Hash28ByteBase162,
  Hash32ByteBase16: () => Hash32ByteBase162,
  HashAsPubKeyHex: () => HashAsPubKeyHex,
  HexBlob: () => import_util2.HexBlob,
  Metadata: () => Metadata,
  Metadatum: () => Metadatum,
  MetadatumList: () => MetadatumList,
  MetadatumMap: () => MetadatumMap,
  NativeScript: () => NativeScript,
  NetworkId: () => NetworkId,
  PaymentAddress: () => PaymentAddress,
  PlutusData: () => PlutusData,
  PlutusDataKind: () => PlutusDataKind,
  PlutusLanguageVersion: () => PlutusLanguageVersion,
  PlutusList: () => PlutusList,
  PlutusMap: () => PlutusMap,
  PlutusV1Script: () => PlutusV1Script,
  PlutusV2Script: () => PlutusV2Script,
  PlutusV3Script: () => PlutusV3Script,
  PolicyId: () => PolicyId,
  PolicyIdToHash: () => PolicyIdToHash,
  PoolId: () => PoolId,
  Redeemer: () => Redeemer,
  RedeemerPurpose: () => RedeemerPurpose,
  RedeemerTag: () => RedeemerTag,
  Redeemers: () => Redeemers,
  RewardAccount: () => RewardAccount,
  RewardAddress: () => RewardAddress,
  SLOT_CONFIG_NETWORK: () => SLOT_CONFIG_NETWORK,
  Script: () => Script,
  Slot: () => Slot,
  StakeDelegation: () => StakeDelegation,
  StakeRegistration: () => StakeRegistration,
  Transaction: () => Transaction,
  TransactionBody: () => TransactionBody,
  TransactionId: () => TransactionId,
  TransactionInput: () => TransactionInput,
  TransactionMetadatumKind: () => TransactionMetadatumKind,
  TransactionOutput: () => TransactionOutput,
  TransactionUnspentOutput: () => TransactionUnspentOutput,
  TransactionWitnessSet: () => TransactionWitnessSet,
  TxCBOR: () => TxCBOR2,
  Value: () => Value,
  VkeyWitness: () => VkeyWitness,
  addressFromBech32: () => addressFromBech32,
  addressFromCredential: () => addressFromCredential,
  addressFromCredentials: () => addressFromCredentials,
  addressFromValidator: () => addressFromValidator,
  blake2b_224: () => blake2b_224,
  blake2b_256: () => blake2b_256,
  derivePublicKey: () => derivePublicKey,
  entropyToMnemonic: () => entropyToMnemonic2,
  fromHex: () => fromHex,
  generateMnemonic: () => generateMnemonic2,
  getPaymentAddress: () => getPaymentAddress,
  hardCodedProtocolParams: () => hardCodedProtocolParams,
  mnemonicToEntropy: () => mnemonicToEntropy2,
  sha2_256: () => sha2_256,
  sha3_256: () => sha3_2562,
  signMessage: () => signMessage,
  toHex: () => toHex,
  typedHex: () => import_util2.typedHex,
  wordlist: () => import_english.wordlist
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var import_util = require("@cardano-sdk/util");
var C = __toESM(require("@cardano-sdk/core"));
var Crypto = __toESM(require("@cardano-sdk/crypto"));
var Slot = C.Cardano.Slot;
var Value = C.Serialization.Value;
var Transaction = C.Serialization.Transaction;
var TxCBOR2 = C.TxCBOR;
var TransactionId = C.Cardano.TransactionId;
var TransactionBody = C.Serialization.TransactionBody;
var TransactionWitnessSet = C.Serialization.TransactionWitnessSet;
var TransactionUnspentOutput = C.Serialization.TransactionUnspentOutput;
var TransactionInput = C.Serialization.TransactionInput;
var TransactionOutput = C.Serialization.TransactionOutput;
var PlutusData = C.Serialization.PlutusData;
var ConstrPlutusData = C.Serialization.ConstrPlutusData;
var PlutusList = C.Serialization.PlutusList;
var PlutusMap = C.Serialization.PlutusMap;
var PlutusDataKind = C.Serialization.PlutusDataKind;
var Redeemers = C.Serialization.Redeemers;
var Redeemer = C.Serialization.Redeemer;
var RedeemerPurpose = C.Cardano.RedeemerPurpose;
var RedeemerTag = C.Serialization.RedeemerTag;
var Script = C.Serialization.Script;
var PolicyId = C.Cardano.PolicyId;
var AssetName = C.Cardano.AssetName;
var AssetId = C.Cardano.AssetId;
var Address = C.Cardano.Address;
var RewardAddress = C.Cardano.RewardAddress;
var AddressType = C.Cardano.AddressType;
var PaymentAddress = C.Cardano.PaymentAddress;
var Credential = C.Serialization.Credential;
var Ed25519PublicKeyHex2 = Crypto.Ed25519PublicKeyHex;
var Ed25519PrivateNormalKeyHex = (value) => (0, import_util.typedHex)(value, 64);
var Ed25519PrivateExtendedKeyHex = (value) => (0, import_util.typedHex)(value, 128);
var Bip32PrivateKeyHex = (value) => (0, import_util.typedHex)(value, 192);
var Ed25519KeyHashHex2 = Crypto.Ed25519KeyHashHex;
var Hash28ByteBase162 = Crypto.Hash28ByteBase16;
var Hash32ByteBase162 = Crypto.Hash32ByteBase16;
var CredentialType = C.Cardano.CredentialType;
var Certificate = C.Serialization.Certificate;
var PoolId = C.Cardano.PoolId;
var StakeRegistration = C.Serialization.StakeRegistration;
var StakeDelegation = C.Serialization.StakeDelegation;
var CertificateType = C.Cardano.CertificateType;
var VkeyWitness = C.Serialization.VkeyWitness;
var Ed25519SignatureHex2 = Crypto.Ed25519SignatureHex;
var Ed25519PublicKey2 = Crypto.Ed25519PublicKey;
var Ed25519Signature2 = Crypto.Ed25519Signature;
var Bip32PrivateKey2 = Crypto.Bip32PrivateKey;
var Bip32PublicKey2 = Crypto.Bip32PublicKey;
var PlutusLanguageVersion = C.Cardano.PlutusLanguageVersion;
var NativeScript = C.Serialization.NativeScript;
var PlutusV1Script = C.Serialization.PlutusV1Script;
var PlutusV2Script = C.Serialization.PlutusV2Script;
var PlutusV3Script = C.Serialization.PlutusV3Script;
var Costmdls = C.Serialization.Costmdls;
var CostModel = C.Serialization.CostModel;
var CborWriter = C.Serialization.CborWriter;
var CborReader = C.Serialization.CborReader;
var CborReaderState = C.Serialization.CborReaderState;
var RewardAccount = C.Cardano.RewardAccount;
var Hash = C.Serialization.Hash;
var DatumHash = Crypto.Hash32ByteBase16;
var Datum = C.Serialization.Datum;
var ExUnits = C.Serialization.ExUnits;
var NetworkId = C.Cardano.NetworkId;
var DatumKind = C.Serialization.DatumKind;
var AuxiliaryData = C.Serialization.AuxiliaryData;
var Metadata = C.Serialization.GeneralTransactionMetadata;
var Metadatum = C.Serialization.TransactionMetadatum;
var MetadatumMap = C.Serialization.MetadatumMap;
var MetadatumList = C.Serialization.MetadatumList;
var TransactionMetadatumKind = C.Serialization.TransactionMetadatumKind;
var SLOT_CONFIG_NETWORK = {
  Mainnet: { zeroTime: 1596059091e3, zeroSlot: 4492800, slotLength: 1e3 },
  Preview: { zeroTime: 1666656e6, zeroSlot: 0, slotLength: 1e3 },
  Preprod: {
    zeroTime: 16540416e5 + 1728e6,
    zeroSlot: 86400,
    slotLength: 1e3
  }
};

// src/util.ts
var C2 = __toESM(require("@cardano-sdk/core"));
var import_util2 = require("@cardano-sdk/util");
var import_sha256 = require("@noble/hashes/sha256");
var sha3 = __toESM(require("@noble/hashes/sha3"));
var blake = __toESM(require("blakejs"));
var bip39 = __toESM(require("@scure/bip39"));
var import_ed25519 = require("@noble/curves/ed25519");
var import_english = require("@scure/bip39/wordlists/english");
function getPaymentAddress(address) {
  const bech = address.toBech32();
  if (bech.__opaqueString == "RewardAccount") {
    throw new Error(
      "getPaymentAddress: failed because a reward account was passed in!"
    );
  }
  return bech;
}
function PolicyIdToHash(policy) {
  return policy;
}
function HashAsPubKeyHex(hash) {
  return hash;
}
function fromHex(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error("Invalid hexString length");
  }
  const byteArray = new Uint8Array(hexString.length / 2);
  for (let i = 0, j = 0; i < hexString.length; i += 2, j++) {
    byteArray[j] = parseInt(hexString.substr(i, 2), 16);
  }
  return byteArray;
}
function toHex(byteArray) {
  let hexString = "";
  for (let i = 0; i < byteArray.length; i++) {
    hexString += ("0" + (byteArray[i] & 255).toString(16)).slice(-2);
  }
  return hexString;
}
function sha2_256(data) {
  return Hash32ByteBase162(toHex((0, import_sha256.sha256)(fromHex(data))));
}
function sha3_2562(data) {
  return Hash32ByteBase162(toHex(sha3.sha3_256(fromHex(data))));
}
function blake2b_256(data) {
  return Hash32ByteBase162(blake.blake2bHex(fromHex(data), void 0, 32));
}
function blake2b_224(data) {
  return Hash28ByteBase162(blake.blake2bHex(fromHex(data), void 0, 28));
}
function derivePublicKey(privateKey) {
  if (privateKey.length > 64) {
    return Ed25519PublicKeyHex2(
      toHex(import_ed25519.ed25519.getPublicKey(fromHex(privateKey.slice(0, 64))))
    );
  } else {
    return Ed25519PublicKeyHex2(toHex(import_ed25519.ed25519.getPublicKey(fromHex(privateKey))));
  }
}
function signMessage(message, privateKey) {
  return Ed25519SignatureHex2(toHex(import_ed25519.ed25519.sign(message, privateKey.slice(0, 64))));
}
var generateMnemonic2 = bip39.generateMnemonic;
var entropyToMnemonic2 = bip39.entropyToMnemonic;
var mnemonicToEntropy2 = bip39.mnemonicToEntropy;
var addressFromBech32 = Address.fromBech32;
var addressFromValidator = (network, validator) => new Address({
  paymentPart: { hash: validator.hash(), type: CredentialType.ScriptHash },
  type: AddressType.EnterpriseScript,
  networkId: network
});
var addressFromCredential = (network, credential) => {
  const cred = credential.toCore();
  let type;
  if (cred.type == CredentialType.KeyHash) {
    type = AddressType.EnterpriseKey;
  } else {
    type = AddressType.EnterpriseScript;
  }
  return new Address({
    paymentPart: credential.toCore(),
    type,
    networkId: network
  });
};
var addressFromCredentials = (network, paymentCredential, delegationCredential) => {
  const pCred = paymentCredential.toCore();
  const dCred = delegationCredential?.toCore();
  let type;
  if (!dCred) {
    if (pCred.type == CredentialType.KeyHash) {
      type = AddressType.EnterpriseKey;
    } else {
      type = AddressType.EnterpriseScript;
    }
  } else {
    if (pCred.type == CredentialType.KeyHash) {
      if (dCred.type == CredentialType.KeyHash) {
        type = AddressType.BasePaymentKeyStakeKey;
      } else {
        type = AddressType.BasePaymentKeyStakeScript;
      }
    } else {
      if (dCred.type == CredentialType.KeyHash) {
        type = AddressType.BasePaymentScriptStakeKey;
      } else {
        type = AddressType.BasePaymentScriptStakeScript;
      }
    }
  }
  return new Address({
    paymentPart: paymentCredential.toCore(),
    delegationPart: delegationCredential?.toCore(),
    type,
    networkId: network
  });
};
var CborSet = C2.Serialization.CborSet;

// src/params.ts
var hardCodedProtocolParams = {
  coinsPerUtxoByte: 4310,
  // The number of coins per UTXO byte.
  maxTxSize: 16384,
  // The maximum transaction size.
  minFeeCoefficient: 44,
  // The minimum fee coefficient.
  minFeeConstant: 155381,
  // The minimum fee constant.
  maxBlockBodySize: 90112,
  // The maximum block body size.
  maxBlockHeaderSize: 1100,
  // The maximum block header size.
  stakeKeyDeposit: 2e6,
  // The stake key deposit.
  poolDeposit: 5e8,
  // The pool deposit.
  poolRetirementEpochBound: 18,
  // The pool retirement epoch bound.
  desiredNumberOfPools: 500,
  // The desired number of pools.
  poolInfluence: "3/10",
  // The pool influence.
  monetaryExpansion: "3/1000",
  // The monetary expansion.
  treasuryExpansion: "1/5",
  // The treasury expansion.
  minPoolCost: 17e7,
  // The minimum pool cost.
  protocolVersion: { major: 8, minor: 0 },
  // The protocol version.
  maxValueSize: 5e3,
  // The maximum value size.
  collateralPercentage: 150 / 100,
  // The collateral percentage.
  maxCollateralInputs: 3,
  // The maximum collateral inputs.
  costModels: (/* @__PURE__ */ new Map()).set(
    0,
    [
      205665,
      812,
      1,
      1,
      1e3,
      571,
      0,
      1,
      1e3,
      24177,
      4,
      1,
      1e3,
      32,
      117366,
      10475,
      4,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      100,
      100,
      23e3,
      100,
      19537,
      32,
      175354,
      32,
      46417,
      4,
      221973,
      511,
      0,
      1,
      89141,
      32,
      497525,
      14068,
      4,
      2,
      196500,
      453240,
      220,
      0,
      1,
      1,
      1e3,
      28662,
      4,
      2,
      245e3,
      216773,
      62,
      1,
      1060367,
      12586,
      1,
      208512,
      421,
      1,
      187e3,
      1e3,
      52998,
      1,
      80436,
      32,
      43249,
      32,
      1e3,
      32,
      80556,
      1,
      57667,
      4,
      1e3,
      10,
      197145,
      156,
      1,
      197145,
      156,
      1,
      204924,
      473,
      1,
      208896,
      511,
      1,
      52467,
      32,
      64832,
      32,
      65493,
      32,
      22558,
      32,
      16563,
      32,
      76511,
      32,
      196500,
      453240,
      220,
      0,
      1,
      1,
      69522,
      11687,
      0,
      1,
      60091,
      32,
      196500,
      453240,
      220,
      0,
      1,
      1,
      196500,
      453240,
      220,
      0,
      1,
      1,
      806990,
      30482,
      4,
      1927926,
      82523,
      4,
      265318,
      0,
      4,
      0,
      85931,
      32,
      205665,
      812,
      1,
      1,
      41182,
      32,
      212342,
      32,
      31220,
      32,
      32696,
      32,
      43357,
      32,
      32247,
      32,
      38314,
      32,
      57996947,
      18975,
      10
    ]
  ).set(
    1,
    [
      205665,
      812,
      1,
      1,
      1e3,
      571,
      0,
      1,
      1e3,
      24177,
      4,
      1,
      1e3,
      32,
      117366,
      10475,
      4,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      23e3,
      100,
      100,
      100,
      23e3,
      100,
      19537,
      32,
      175354,
      32,
      46417,
      4,
      221973,
      511,
      0,
      1,
      89141,
      32,
      497525,
      14068,
      4,
      2,
      196500,
      453240,
      220,
      0,
      1,
      1,
      1e3,
      28662,
      4,
      2,
      245e3,
      216773,
      62,
      1,
      1060367,
      12586,
      1,
      208512,
      421,
      1,
      187e3,
      1e3,
      52998,
      1,
      80436,
      32,
      43249,
      32,
      1e3,
      32,
      80556,
      1,
      57667,
      4,
      1e3,
      10,
      197145,
      156,
      1,
      197145,
      156,
      1,
      204924,
      473,
      1,
      208896,
      511,
      1,
      52467,
      32,
      64832,
      32,
      65493,
      32,
      22558,
      32,
      16563,
      32,
      76511,
      32,
      196500,
      453240,
      220,
      0,
      1,
      1,
      69522,
      11687,
      0,
      1,
      60091,
      32,
      196500,
      453240,
      220,
      0,
      1,
      1,
      196500,
      453240,
      220,
      0,
      1,
      1,
      1159724,
      392670,
      0,
      2,
      806990,
      30482,
      4,
      1927926,
      82523,
      4,
      265318,
      0,
      4,
      0,
      85931,
      32,
      205665,
      812,
      1,
      1,
      41182,
      32,
      212342,
      32,
      31220,
      32,
      32696,
      32,
      43357,
      32,
      32247,
      32,
      38314,
      32,
      35892428,
      10,
      57996947,
      18975,
      10,
      38887044,
      32947,
      10
    ]
  ),
  prices: { memory: 577 / 1e4, steps: 721e-7 },
  // The prices.
  maxExecutionUnitsPerTransaction: { memory: 14e6, steps: 1e10 },
  // The maximum execution units per transaction.
  maxExecutionUnitsPerBlock: { memory: 62e6, steps: 2e10 }
  // The maximum execution units per block.
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Address,
  AddressType,
  AssetId,
  AssetName,
  AuxiliaryData,
  Bip32PrivateKey,
  Bip32PrivateKeyHex,
  Bip32PublicKey,
  CborReader,
  CborReaderState,
  CborSet,
  CborWriter,
  Certificate,
  CertificateType,
  ConstrPlutusData,
  CostModel,
  Costmdls,
  Credential,
  CredentialType,
  Datum,
  DatumHash,
  DatumKind,
  Ed25519KeyHashHex,
  Ed25519PrivateExtendedKeyHex,
  Ed25519PrivateNormalKeyHex,
  Ed25519PublicKey,
  Ed25519PublicKeyHex,
  Ed25519Signature,
  Ed25519SignatureHex,
  ExUnits,
  Hash,
  Hash28ByteBase16,
  Hash32ByteBase16,
  HashAsPubKeyHex,
  HexBlob,
  Metadata,
  Metadatum,
  MetadatumList,
  MetadatumMap,
  NativeScript,
  NetworkId,
  PaymentAddress,
  PlutusData,
  PlutusDataKind,
  PlutusLanguageVersion,
  PlutusList,
  PlutusMap,
  PlutusV1Script,
  PlutusV2Script,
  PlutusV3Script,
  PolicyId,
  PolicyIdToHash,
  PoolId,
  Redeemer,
  RedeemerPurpose,
  RedeemerTag,
  Redeemers,
  RewardAccount,
  RewardAddress,
  SLOT_CONFIG_NETWORK,
  Script,
  Slot,
  StakeDelegation,
  StakeRegistration,
  Transaction,
  TransactionBody,
  TransactionId,
  TransactionInput,
  TransactionMetadatumKind,
  TransactionOutput,
  TransactionUnspentOutput,
  TransactionWitnessSet,
  TxCBOR,
  Value,
  VkeyWitness,
  addressFromBech32,
  addressFromCredential,
  addressFromCredentials,
  addressFromValidator,
  blake2b_224,
  blake2b_256,
  derivePublicKey,
  entropyToMnemonic,
  fromHex,
  generateMnemonic,
  getPaymentAddress,
  hardCodedProtocolParams,
  mnemonicToEntropy,
  sha2_256,
  sha3_256,
  signMessage,
  toHex,
  typedHex,
  wordlist
});
