import { TransactionUnspentOutput, Value, ProtocolParameters, Address, Evaluator, NetworkId, PlutusData, PolicyId, AssetName, TransactionOutput, Datum, Script, Transaction, Credential, PoolId, Slot, RewardAccount, Ed25519KeyHashHex, AuxiliaryData } from '@blaze-cardano/core';
export { v as Value, m as makeValue } from './value-C_J_5qtu.mjs';
import * as _sinclair_typebox from '@sinclair/typebox';
import { TSchema, Static as Static$1, TProperties, TLiteralValue, TLiteral } from '@sinclair/typebox';

/**
 * The result of a coin selection operation.
 * It includes the selected inputs, the total value of the selected inputs, and the remaining inputs.
 */
type SelectionResult = {
    selectedInputs: TransactionUnspentOutput[];
    selectedValue: Value;
    inputs: TransactionUnspentOutput[];
};

/**
 * A builder class for constructing Cardano transactions with various components like inputs, outputs, and scripts.
 */
declare class TxBuilder {
    readonly params: ProtocolParameters;
    private preCompleteHooks;
    private body;
    private auxiliaryData?;
    private redeemers;
    private utxos;
    private utxoScope;
    private scriptScope;
    private scriptSeen;
    private changeAddress?;
    private rewardAddress?;
    private networkId?;
    private changeOutputIndex?;
    private plutusData;
    private requiredWitnesses;
    private requiredNativeScripts;
    private requiredPlutusScripts;
    private usedLanguages;
    private extraneousDatums;
    private fee;
    private additionalSigners;
    private evaluator?;
    private consumedMintHashes;
    private consumedWithdrawalHashes;
    private consumedSpendInputs;
    private minimumFee;
    private coinSelector;
    /**
     * Constructs a new instance of the TxBuilder class.
     * Initializes a new transaction body with an empty set of inputs, outputs, and no fee.
     */
    constructor(params: ProtocolParameters);
    private insertSorted;
    /**
     * Sets the change address for the transaction.
     * This address will receive any remaining funds not allocated to outputs or fees.
     *
     * @param {Address} address - The address to receive the change.
     * @returns {TxBuilder} The same transaction builder
     */
    setChangeAddress(address: Address): this;
    /**
     * Sets the reward address for the transaction.
     * This address will be used for delegation purposes and also stake key component of the transaction.
     *
     * @param {Address} address - The reward address
     * @returns {TxBuilder} The same transaction builder
     */
    setRewardAddress(address: Address): this;
    /**
     * Sets the evaluator for the transaction builder.
     * The evaluator is used to execute Plutus scripts during transaction building.
     *
     * @param {Evaluator} evaluator - The evaluator to be used for script execution.
     * @returns {TxBuilder} The same transaction builder
     */
    useEvaluator(evaluator: Evaluator): this;
    /**
     * Sets a custom coin selector function for the transaction builder.
     * This function will be used to select inputs during the transaction building process.
     *
     * @param {(inputs: TransactionUnspentOutput[], dearth: Value): SelectionResult} selector - The coin selector function to use.
     * @returns {TxBuilder} The same transaction builder
     */
    useCoinSelector(selector: (inputs: TransactionUnspentOutput[], dearth: Value) => SelectionResult): TxBuilder;
    /**
     * Sets the network ID for the transaction builder.
     * The network ID is used to determine which network the transaction is intended for.
     *
     * @param {NetworkId} networkId - The network ID to set.
     * @returns {TxBuilder} The same transaction builder
     */
    setNetworkId(networkId: NetworkId): this;
    /**
     * The additional signers field is used to add additional signing counts for fee calculation.
     * These will be included in the signing phase at a later stage.
     * This is needed due to native scripts signees being non-deterministic.
     * @param {number} amount - The amount of additional signers
     * @returns {TxBuilder} The same transaction builder
     */
    addAdditionalSigners(amount: number): this;
    /**
     * Sets the minimum fee for the transaction.
     * This fee will be used during the transaction building process.
     *
     * @param {bigint} fee - The minimum fee to be set.
     * @returns {TxBuilder} The same transaction builder
     */
    setMinimumFee(fee: bigint): this;
    /**
     * Adds a reference input to the transaction. Reference inputs are used to refer to outputs from previous transactions
     * without spending them, allowing scripts to read their data. This can be useful for various contract logic, such as
     * checking the state of a datum without consuming the UTxO that holds it.
     *
     * @param {TransactionUnspentOutput} utxo - The unspent transaction output to add as a reference input.
     * @returns {TxBuilder} The same transaction builder
     * @throws {Error} If the input to be added is already present in the list of reference inputs, to prevent duplicates.
     */
    addReferenceInput(utxo: TransactionUnspentOutput): this;
    /**
     * Adds an input to the transaction. This method is responsible for including a new input, which represents
     * a reference to an unspent transaction output (UTxO) that will be consumed by the transaction. Optionally,
     * a redeemer and an unhashed datum can be provided for script validation purposes.
     *
     * @param {TransactionUnspentOutput} utxo - The UTxO to be consumed as an input.
     * @param {PlutusData} [redeemer] - Optional. The redeemer data for script validation, required for spending Plutus script-locked UTxOs.
     * @param {PlutusData} [unhashDatum] - Optional. The unhashed datum, required if the UTxO being spent includes a datum hash instead of inline datum.
     * @returns {TxBuilder} The same transaction builder
     * @throws {Error} If attempting to add a duplicate input, if the UTxO payment key is missing, if attempting to spend with a redeemer for a KeyHash credential,
     *                 if attempting to spend without a datum when required, or if providing both an inline datum and an unhashed datum.
     */
    addInput(utxo: TransactionUnspentOutput, redeemer?: PlutusData, unhashDatum?: PlutusData): this;
    /**
     * Adds unspent transaction outputs (UTxOs) to the set of UTxOs available for this transaction.
     * These UTxOs can then be used for balancing the transaction, ensuring that inputs and outputs are equal.
     *
     * @param {TransactionUnspentOutput[]} utxos - The unspent transaction outputs to add.
     * @returns {TxBuilder} The same transaction builder
     */
    addUnspentOutputs(utxos: TransactionUnspentOutput[]): this;
    /**
     * Adds minting information to the transaction. This includes specifying the policy under which assets are minted,
     * the assets to be minted, and an optional redeemer for Plutus scripts.
     *
     * @param {PolicyId} policy - The policy ID under which the assets are minted.
     * @param {Map<AssetName, bigint>} assets - A map of asset names to the amounts being minted.
     * @param {PlutusData} [redeemer] - Optional. A redeemer to be used if the minting policy requires Plutus script validation.
     */
    addMint(policy: PolicyId, assets: Map<AssetName, bigint>, redeemer?: PlutusData): this;
    /**
     * This method checks and alters the output of a transaction.
     * It ensures that the output meets the minimum ada requirements and does not exceed the maximum value size.
     *
     * @param {TransactionOutput} output - The transaction output to be checked and altered.
     * @returns {TransactionOutput} The altered transaction output.
     * @throws {Error} If the output does not meet the minimum ada requirements or exceeds the maximum value size.
     */
    private checkAndAlterOutput;
    /**
     * Adds a transaction output to the current transaction body. This method also ensures that the minimum ada
     * requirements are met for the output. After adding the output, it updates the transaction body's outputs.
     * It also checks if the output value exceeds the maximum value size.
     *
     * @param {TransactionOutput} output - The transaction output to be added.
     * @returns {TxBuilder} The same transaction builder
     */
    addOutput(output: TransactionOutput): this;
    /**
     * Returns the number of transaction outputs in the current transaction body.
     *
     * @returns {number} The number of transaction outputs.
     */
    get outputsCount(): number;
    /**
     * Adds a payment in lovelace to the transaction output.
     * This method ensures that the address is valid and the payment is added to the transaction output.
     *
     * @param {Address} address - The address to send the payment to.
     * @param {bigint} lovelace - The amount of lovelace to send.
     * @returns {TxBuilder} The same transaction builder
     */
    payLovelace(address: Address, lovelace: bigint): this;
    /**
     * Adds a payment in assets to the transaction output.
     * This method ensures that the address is valid and the payment is added to the transaction output.
     *
     * @param {Address} address - The address to send the payment to.
     * @param {Value} value - The value of the assets to send.
     * @returns {TxBuilder} The same transaction builder
     */
    payAssets(address: Address, value: Value): this;
    /**
     * Locks a specified amount of lovelace to a script.
     * The difference between 'pay' and 'lock' is that you pay to a public key/user,
     * and you lock at a script.
     * This method ensures that the address is valid and the lovelace is locked to the script.
     *
     * @param {Address} address - The address to lock the lovelace to.
     * @param {bigint} lovelace - The amount of lovelace to lock.
     * @param {Datum} datum - The datum to be associated with the locked lovelace.
     * @param {Script} scriptReference - The reference to the script to lock the lovelace to.
     * @returns {TxBuilder} The same transaction builder
     */
    lockLovelace(address: Address, lovelace: bigint, datum: Datum, scriptReference?: Script): this;
    /**
     * Locks a specified amount of assets to a script.
     * The difference between 'pay' and 'lock' is that you pay to a public key/user,
     * and you lock at a script.
     * This method ensures that the address is valid and the assets are locked to the script.
     *
     * @param {Address} address - The address to lock the assets to.
     * @param {Value} value - The value of the assets to lock.
     * @param {Datum} datum - The datum to be associated with the locked assets.
     * @param {Script} scriptReference - The reference to the script to lock the assets to.
     * @returns {TxBuilder} The same transaction builder
     */
    lockAssets(address: Address, value: Value, datum: Datum, scriptReference?: Script): this;
    /**
     * Adds a Plutus datum to the transaction. This datum is not directly associated with any particular output but may be used
     * by scripts during transaction validation. This method is useful for including additional information that scripts may
     * need to validate the transaction without requiring it to be attached to a specific output.
     *
     * @param {PlutusData} datum - The Plutus datum to be added to the transaction.
     * @returns {TxBuilder} The same transaction builder
     */
    provideDatum(datum: PlutusData): this;
    /**
     * Evaluates the scripts for the given draft transaction and calculates the execution units and fees required.
     * This function iterates over all UTXOs within the transaction's scope, simulates the execution of associated scripts,
     * and aggregates the execution units. It then calculates the total fee based on the execution units and updates the
     * transaction's redeemers with the new execution units.
     *
     * @param {Transaction} draft_tx - The draft transaction to evaluate.
     * @returns {Promise<bigint>} The total fee calculated based on the execution units of the scripts.
     */
    private evaluate;
    /**
     * Builds the transaction witness set required for the transaction.
     * This includes collecting all necessary scripts (native, Plutus V1, V2, V3),
     * vkey witnesses, redeemers, and Plutus data required for script validation.
     * It organizes these components into a structured format that can be
     * serialized and included in the transaction.
     *
     * @returns {TransactionWitnessSet} A constructed transaction witness set.
     * @throws {Error} If a required script cannot be resolved by its hash.
     */
    private buildTransactionWitnessSet;
    /**
     * Calculates the net value difference between the inputs and outputs of a transaction,
     * including minted values, withdrawals, and subtracting a fixed fee amount.
     * This function is used to determine the excess value that needs to be returned as change.
     *
     * @returns {Value} The net value that represents the transaction's pitch.
     * @throws {Error} If a corresponding UTxO for an input cannot be found.
     */
    private getPitch;
    /**
     * Generates a script data hash for the transaction if there are any datums or redeemers present.
     * This hash is crucial for the validation of Plutus scripts in the transaction.
     *
     * @param {TransactionWitnessSet} tw - The transaction witness set containing Plutus data.
     * @returns {Hash32ByteBase16 | undefined} The script data hash if datums or redeemers are present, otherwise undefined.
     */
    private getScriptDataHash;
    /**
     * Adjusts the balance of the transaction by creating or updating a change output.
     * This method takes the excess value from the transaction, removes any zero-valued
     * tokens from the multiasset map, and then either creates a new change output or
     * updates an existing one with the adjusted value.
     *
     * @param {Value} excessValue - The excess value that needs to be returned as change.
     */
    private balanceChange;
    /**
     * Calculates the transaction fees based on the transaction size and parameters.
     * It updates the transaction body with the calculated fee.
     *
     * @param {Transaction} draft_tx - The draft transaction to calculate fees for.
     */
    private calculateFees;
    /**
     * Prepares the collateral for the transaction by selecting suitable UTXOs.
     * Throws an error if suitable collateral cannot be found or if some inputs cannot be resolved.
     */
    private prepareCollateral;
    /**
     * Balances the collateral change by creating a transaction output that returns the excess collateral.
     * Throws an error if the change address is not set.
     */
    private balanceCollateralChange;
    /**
     * Completes the transaction by performing several key operations:
     * - Verifies the presence of a change address.
     * - Gathers inputs and performs coin selection if necessary.
     * - Balances the change output.
     * - Builds the transaction witness set.
     * - Calculates the script data hash.
     * - Estimates and sets the transaction fee.
     * - Merges the fee value with the excess value and rebalances the change.
     *
     * @throws {Error} If the change address is not set, or if the coin selection fails to eliminate negative values,
     *                 or if balancing the change output fails.
     * @returns {Promise<Transaction>} A new Transaction object with all components set and ready for submission.
     */
    complete(): Promise<Transaction>;
    /**
     * Adds a certificate to delegate a staker to a pool
     *
     * @param {Credential} delegator - The credential of the staker to delegate.
     * @param {PoolId} poolId - The ID of the pool to delegate to.
     * @param {PlutusData} [redeemer] - Optional. A redeemer to be used if the delegation requires Plutus script validation.
     * @returns {TxBuilder} The updated transaction builder.
     */
    addDelegation(delegator: Credential, poolId: PoolId, redeemer?: PlutusData): TxBuilder;
    /**
     * This method delegates the selected reward address to a pool.
     * It first checks if the reward address is set and if it has a stake component.
     * If both conditions are met, it adds a delegation to the transaction.
     *
     * @param {PoolId} poolId - The ID of the pool to delegate the reward address to.
     * @throws {Error} If the reward address is not set or if the method is unimplemented.
     */
    delegate(poolId: PoolId, redeemer?: PlutusData): this;
    /**
     * Adds a certificate to register a staker.
     * @param {Credential} credential - The credential to register.
     * @throws {Error} Method not implemented.
     */
    addRegisterStake(credential: Credential): this;
    /**
     * Adds a certificate to deregister a staker.
     * @throws {Error} Method not implemented.
     */
    addDeregisterStake(): void;
    /**
     * Adds a certificate to register a pool.
     * @throws {Error} Method not implemented.
     */
    addRegisterPool(): void;
    /**
     * Adds a certificate to retire a pool.
     * @throws {Error} Method not implemented.
     */
    addRetirePool(): void;
    /**
     * Specifies the exact time when the transaction becomes valid.
     *
     * @param {Slot} validFrom - The slot from which the transaction becomes valid.
     * @throws {Error} If the validity start interval is already set.
     * @returns {TxBuilder} The instance of this TxBuilder for chaining.
     */
    setValidFrom(validFrom: Slot): TxBuilder;
    /**
     * Specifies the exact time when the transaction expires.
     *
     * @param {Slot} validUntil - The slot until which the transaction is valid.
     * @throws {Error} If the time to live is already set.
     * @returns {TxBuilder} The instance of this TxBuilder for chaining.
     */
    setValidUntil(validUntil: Slot): TxBuilder;
    /**
     * Adds a withdrawal to the transaction. This method allows for the withdrawal of funds from a staking reward account.
     * Optionally, a redeemer can be provided for script validation purposes.
     *
     * @param {C.Cardano.RewardAccount} address - The reward account from which to withdraw.
     * @param {bigint} amount - The amount of ADA to withdraw.
     * @param {PlutusData} [redeemer] - Optional. The redeemer data for script validation.
     * @returns {TxBuilder} The same transaction builder
     * @throws {Error} If the reward account does not have a stake credential or if any other error occurs.
     */
    addWithdrawal(address: RewardAccount, amount: bigint, redeemer?: PlutusData): this;
    /**
     * Adds a required signer to the transaction. This is necessary for transactions that must be explicitly signed by a particular key.
     *
     * @param {Ed25519KeyHashHex} signer - The hash of the Ed25519 public key that is required to sign the transaction.
     * @returns {TxBuilder} The same transaction builder
     */
    addRequiredSigner(signer: Ed25519KeyHashHex): this;
    /**
     * Computes the hash of the auxiliary data if it exists.
     *
     * @param {AuxiliaryData} auxiliaryData - The auxiliary data to hash.
     * @returns {Hash32ByteBase16 | undefined} The hash of the auxiliary data or undefined if no auxiliary data is provided.
     */
    private getAuxiliaryDataHash;
    /**
     * Sets the auxiliary data for the transaction and updates the transaction's auxiliary data hash.
     *
     * @param {AuxiliaryData} auxiliaryData - The auxiliary data to set.
     * @returns {TxBuilder} The same transaction builder
     */
    setAuxiliaryData(auxiliaryData: AuxiliaryData): TxBuilder;
    /**
     * Adds a script to the transaction's script scope. If the script is already provided via a reference script,
     * it will not be explicitly used again. This method ensures that each script is only included once in the
     * transaction, either directly or by reference, to optimize the transaction size and processing.
     *
     * @param {Script} script - The script to be added to the transaction's script scope.
     * @returns {TxBuilder} The same transaction builder
     */
    provideScript(script: Script): this;
    /**
     * Adds a pre-complete hook to the transaction builder. This hook will be executed
     * before the transaction is finalized.
     *
     * Pre-complete hooks are useful for performing last-minute modifications or
     * validations on the transaction before it's completed. Multiple hooks can be
     * added, and they will be executed in the order they were added.
     *
     * @param {(tx: TxBuilder) => Promise<void>} hook - A function that takes the TxBuilder
     * instance as an argument and performs some operation. The hook should be asynchronous.
     * @returns {TxBuilder} The same transaction builder instance for method chaining.
     */
    addPreCompleteHook(hook: (tx: TxBuilder) => Promise<void>): TxBuilder;
}

type PConstructor = {
    dataType: "constructor";
    index: number;
    fields: PSchema[];
    title?: string;
};
type PList = {
    dataType: "list";
    items: PSchema[] | PSchema;
    title?: string;
};
type PEnum = {
    title?: string;
    anyOf: PConstructor[];
};
type PMap = {
    dataType: "map";
    keys: PSchema;
    values: PSchema;
};
type PSchema = {
    dataType: "integer" | "bytes" | `#${"unit" | "boolean" | "integer" | "bytes" | "string" | "pair" | "list"}`;
} | PList | PConstructor | PEnum | PMap;
type Static<T extends TSchema, P extends unknown[] = []> = Static$1<T, P>;
declare const Data: {
    Integer: (options?: {
        minimum?: number;
        maximum?: number;
        exclusiveMinimum?: number;
        exclusiveMaximum?: number;
    }) => _sinclair_typebox.TUnsafe<bigint>;
    Bytes: (options?: {
        minLength?: number;
        maxLength?: number;
        enum?: string[];
    }) => _sinclair_typebox.TUnsafe<string>;
    Boolean: () => _sinclair_typebox.TUnsafe<boolean>;
    Any: () => TSchema;
    Array: <T extends TSchema>(items: T, options?: {
        minItems?: number;
        maxItems?: number;
        uniqueItems?: boolean;
    }) => _sinclair_typebox.TArray<T>;
    Map: <T extends TSchema, U extends TSchema>(keys: T, values: U, options?: {
        minItems?: number;
        maxItems?: number;
    }) => _sinclair_typebox.TUnsafe<Map<Static<T, []>, Static<U, []>>>;
    /**
     * Object applies by default a PlutusData Constr with index 0.\
     * Set 'hasConstr' to false to serialize Object as PlutusData List.
     */
    Object: <T extends TProperties>(properties: T, options?: {
        hasConstr?: boolean;
    }) => _sinclair_typebox.TObject<T>;
    Enum: <T extends TSchema>(items: T[]) => _sinclair_typebox.TUnion<T[]>;
    /**
     * Tuple is by default a PlutusData List.\
     * Set 'hasConstr' to true to apply a PlutusData Constr with index 0.
     */
    Tuple: <T extends TSchema[]>(items: [...T], options?: {
        hasConstr?: boolean;
    }) => _sinclair_typebox.TTuple<T>;
    Literal: <T extends TLiteralValue>(title: T) => TLiteral<T>;
    Nullable: <T extends TSchema>(item: T) => _sinclair_typebox.TUnsafe<Static<T, []> | null>;
    Void: () => PlutusData;
    castFrom: typeof castFrom;
    castTo: typeof castTo;
    to: typeof to;
    from: typeof from;
};
type Exact<T> = T extends TSchema ? Static<T> : T;
declare function to<T>(data: Exact<T>, type: T): PlutusData;
declare function from<T>(data: PlutusData, type: T): Exact<T>;
declare function castTo<T extends TSchema>(struct: Exact<T>, schema: T): PlutusData;
declare function castFrom<T extends TSchema>(rawData: PlutusData, schema: T): Exact<T>;

export { Data, type Exact, type PConstructor, type PList, type PSchema, type Static, TxBuilder };
